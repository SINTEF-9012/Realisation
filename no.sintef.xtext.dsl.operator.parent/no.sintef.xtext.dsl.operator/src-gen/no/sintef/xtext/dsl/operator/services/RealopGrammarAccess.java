/*
 * generated by Xtext 2.9.2
 */
package no.sintef.xtext.dsl.operator.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class RealopGrammarAccess extends AbstractGrammarElementFinder {
	
	public class RealopElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "no.sintef.xtext.dsl.operator.Realop.Realop");
		private final Assignment cOperatorAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cOperatorOperatorParserRuleCall_0 = (RuleCall)cOperatorAssignment.eContents().get(0);
		
		//Realop:
		//	operator+=Operator*;
		@Override public ParserRule getRule() { return rule; }
		
		//operator+=Operator*
		public Assignment getOperatorAssignment() { return cOperatorAssignment; }
		
		//Operator
		public RuleCall getOperatorOperatorParserRuleCall_0() { return cOperatorOperatorParserRuleCall_0; }
	}
	public class OperatorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "no.sintef.xtext.dsl.operator.Realop.Operator");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cOP_TOKENParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final RuleCall cOPEN_OP_TOKENParserRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final RuleCall cPRE_TOKENParserRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		private final RuleCall cCOND_ST_TOKENParserRuleCall_4 = (RuleCall)cGroup.eContents().get(4);
		private final Assignment cExp_preAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cExp_preExpressionParserRuleCall_5_0 = (RuleCall)cExp_preAssignment_5.eContents().get(0);
		private final RuleCall cCOND_END_TOKENParserRuleCall_6 = (RuleCall)cGroup.eContents().get(6);
		private final RuleCall cPOST_TOKENParserRuleCall_7 = (RuleCall)cGroup.eContents().get(7);
		private final RuleCall cCOND_ST_TOKENParserRuleCall_8 = (RuleCall)cGroup.eContents().get(8);
		private final Assignment cExp_postAssignment_9 = (Assignment)cGroup.eContents().get(9);
		private final RuleCall cExp_postExpressionParserRuleCall_9_0 = (RuleCall)cExp_postAssignment_9.eContents().get(0);
		private final RuleCall cCOND_END_TOKENParserRuleCall_10 = (RuleCall)cGroup.eContents().get(10);
		private final RuleCall cCLOSE_OP_TOKENParserRuleCall_11 = (RuleCall)cGroup.eContents().get(11);
		
		//Operator:
		//	OP_TOKEN name=ID OPEN_OP_TOKEN PRE_TOKEN COND_ST_TOKEN exp_pre=Expression COND_END_TOKEN POST_TOKEN COND_ST_TOKEN
		//	exp_post=Expression COND_END_TOKEN CLOSE_OP_TOKEN;
		@Override public ParserRule getRule() { return rule; }
		
		//OP_TOKEN name=ID OPEN_OP_TOKEN PRE_TOKEN COND_ST_TOKEN exp_pre=Expression COND_END_TOKEN POST_TOKEN COND_ST_TOKEN
		//exp_post=Expression COND_END_TOKEN CLOSE_OP_TOKEN
		public Group getGroup() { return cGroup; }
		
		//OP_TOKEN
		public RuleCall getOP_TOKENParserRuleCall_0() { return cOP_TOKENParserRuleCall_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//OPEN_OP_TOKEN
		public RuleCall getOPEN_OP_TOKENParserRuleCall_2() { return cOPEN_OP_TOKENParserRuleCall_2; }
		
		//PRE_TOKEN
		public RuleCall getPRE_TOKENParserRuleCall_3() { return cPRE_TOKENParserRuleCall_3; }
		
		//COND_ST_TOKEN
		public RuleCall getCOND_ST_TOKENParserRuleCall_4() { return cCOND_ST_TOKENParserRuleCall_4; }
		
		//exp_pre=Expression
		public Assignment getExp_preAssignment_5() { return cExp_preAssignment_5; }
		
		//Expression
		public RuleCall getExp_preExpressionParserRuleCall_5_0() { return cExp_preExpressionParserRuleCall_5_0; }
		
		//COND_END_TOKEN
		public RuleCall getCOND_END_TOKENParserRuleCall_6() { return cCOND_END_TOKENParserRuleCall_6; }
		
		//POST_TOKEN
		public RuleCall getPOST_TOKENParserRuleCall_7() { return cPOST_TOKENParserRuleCall_7; }
		
		//COND_ST_TOKEN
		public RuleCall getCOND_ST_TOKENParserRuleCall_8() { return cCOND_ST_TOKENParserRuleCall_8; }
		
		//exp_post=Expression
		public Assignment getExp_postAssignment_9() { return cExp_postAssignment_9; }
		
		//Expression
		public RuleCall getExp_postExpressionParserRuleCall_9_0() { return cExp_postExpressionParserRuleCall_9_0; }
		
		//COND_END_TOKEN
		public RuleCall getCOND_END_TOKENParserRuleCall_10() { return cCOND_END_TOKENParserRuleCall_10; }
		
		//CLOSE_OP_TOKEN
		public RuleCall getCLOSE_OP_TOKENParserRuleCall_11() { return cCLOSE_OP_TOKENParserRuleCall_11; }
	}
	public class ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "no.sintef.xtext.dsl.operator.Realop.Expression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLhsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cLhsPredicateParserRuleCall_0_0 = (RuleCall)cLhsAssignment_0.eContents().get(0);
		private final Assignment cRhsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cRhsTerminalExpressionParserRuleCall_1_0 = (RuleCall)cRhsAssignment_1.eContents().get(0);
		
		//Expression:
		//	lhs=Predicate rhs=TerminalExpression?;
		@Override public ParserRule getRule() { return rule; }
		
		//lhs=Predicate rhs=TerminalExpression?
		public Group getGroup() { return cGroup; }
		
		//lhs=Predicate
		public Assignment getLhsAssignment_0() { return cLhsAssignment_0; }
		
		//Predicate
		public RuleCall getLhsPredicateParserRuleCall_0_0() { return cLhsPredicateParserRuleCall_0_0; }
		
		//rhs=TerminalExpression?
		public Assignment getRhsAssignment_1() { return cRhsAssignment_1; }
		
		//TerminalExpression
		public RuleCall getRhsTerminalExpressionParserRuleCall_1_0() { return cRhsTerminalExpressionParserRuleCall_1_0; }
	}
	public class TerminalExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "no.sintef.xtext.dsl.operator.Realop.TerminalExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cOpAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cOpLogicParserRuleCall_0_0 = (RuleCall)cOpAssignment_0.eContents().get(0);
		private final Assignment cRhsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cRhsExpressionParserRuleCall_1_0 = (RuleCall)cRhsAssignment_1.eContents().get(0);
		
		//TerminalExpression:
		//	op=Logic rhs=Expression;
		@Override public ParserRule getRule() { return rule; }
		
		//op=Logic rhs=Expression
		public Group getGroup() { return cGroup; }
		
		//op=Logic
		public Assignment getOpAssignment_0() { return cOpAssignment_0; }
		
		//Logic
		public RuleCall getOpLogicParserRuleCall_0_0() { return cOpLogicParserRuleCall_0_0; }
		
		//rhs=Expression
		public Assignment getRhsAssignment_1() { return cRhsAssignment_1; }
		
		//Expression
		public RuleCall getRhsExpressionParserRuleCall_1_0() { return cRhsExpressionParserRuleCall_1_0; }
	}
	public class LogicElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "no.sintef.xtext.dsl.operator.Realop.Logic");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cAndAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cAndAND_TOKENParserRuleCall_0_0 = (RuleCall)cAndAssignment_0.eContents().get(0);
		private final Assignment cOrAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cOrOR_TOKENParserRuleCall_1_0 = (RuleCall)cOrAssignment_1.eContents().get(0);
		private final Assignment cXorAssignment_2 = (Assignment)cAlternatives.eContents().get(2);
		private final RuleCall cXorXOR_TOKENParserRuleCall_2_0 = (RuleCall)cXorAssignment_2.eContents().get(0);
		
		//Logic:
		//	and?=AND_TOKEN | or?=OR_TOKEN | xor?=XOR_TOKEN;
		@Override public ParserRule getRule() { return rule; }
		
		//and?=AND_TOKEN | or?=OR_TOKEN | xor?=XOR_TOKEN
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//and?=AND_TOKEN
		public Assignment getAndAssignment_0() { return cAndAssignment_0; }
		
		//AND_TOKEN
		public RuleCall getAndAND_TOKENParserRuleCall_0_0() { return cAndAND_TOKENParserRuleCall_0_0; }
		
		//or?=OR_TOKEN
		public Assignment getOrAssignment_1() { return cOrAssignment_1; }
		
		//OR_TOKEN
		public RuleCall getOrOR_TOKENParserRuleCall_1_0() { return cOrOR_TOKENParserRuleCall_1_0; }
		
		//xor?=XOR_TOKEN
		public Assignment getXorAssignment_2() { return cXorAssignment_2; }
		
		//XOR_TOKEN
		public RuleCall getXorXOR_TOKENParserRuleCall_2_0() { return cXorXOR_TOKENParserRuleCall_2_0; }
	}
	public class PredicateElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "no.sintef.xtext.dsl.operator.Realop.Predicate");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNegatedAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNegatedNOT_TOKENParserRuleCall_0_0 = (RuleCall)cNegatedAssignment_0.eContents().get(0);
		private final Assignment cPredicateAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cPredicatePredicatesParserRuleCall_1_0 = (RuleCall)cPredicateAssignment_1.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cNameAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cNameIDTerminalRuleCall_3_0 = (RuleCall)cNameAssignment_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//Predicate:
		//	negated?=NOT_TOKEN? predicate=Predicates '(' name=ID ')';
		@Override public ParserRule getRule() { return rule; }
		
		//negated?=NOT_TOKEN? predicate=Predicates '(' name=ID ')'
		public Group getGroup() { return cGroup; }
		
		//negated?=NOT_TOKEN?
		public Assignment getNegatedAssignment_0() { return cNegatedAssignment_0; }
		
		//NOT_TOKEN
		public RuleCall getNegatedNOT_TOKENParserRuleCall_0_0() { return cNegatedNOT_TOKENParserRuleCall_0_0; }
		
		//predicate=Predicates
		public Assignment getPredicateAssignment_1() { return cPredicateAssignment_1; }
		
		//Predicates
		public RuleCall getPredicatePredicatesParserRuleCall_1_0() { return cPredicatePredicatesParserRuleCall_1_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }
		
		//name=ID
		public Assignment getNameAssignment_3() { return cNameAssignment_3; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_3_0() { return cNameIDTerminalRuleCall_3_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
	}
	public class PredicatesElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "no.sintef.xtext.dsl.operator.Realop.Predicates");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cRealisedAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cRealisedPRED_REALISED_TOKENParserRuleCall_0_0 = (RuleCall)cRealisedAssignment_0.eContents().get(0);
		private final Assignment cPositiveAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cPositivePRED_POSITIVE_TOKENParserRuleCall_1_0 = (RuleCall)cPositiveAssignment_1.eContents().get(0);
		private final Assignment cNegativeAssignment_2 = (Assignment)cAlternatives.eContents().get(2);
		private final RuleCall cNegativePRED_NEGATIVE_TOKENParserRuleCall_2_0 = (RuleCall)cNegativeAssignment_2.eContents().get(0);
		
		//Predicates:
		//	realised?=PRED_REALISED_TOKEN | positive?=PRED_POSITIVE_TOKEN | negative?=PRED_NEGATIVE_TOKEN;
		@Override public ParserRule getRule() { return rule; }
		
		//realised?=PRED_REALISED_TOKEN | positive?=PRED_POSITIVE_TOKEN | negative?=PRED_NEGATIVE_TOKEN
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//realised?=PRED_REALISED_TOKEN
		public Assignment getRealisedAssignment_0() { return cRealisedAssignment_0; }
		
		//PRED_REALISED_TOKEN
		public RuleCall getRealisedPRED_REALISED_TOKENParserRuleCall_0_0() { return cRealisedPRED_REALISED_TOKENParserRuleCall_0_0; }
		
		//positive?=PRED_POSITIVE_TOKEN
		public Assignment getPositiveAssignment_1() { return cPositiveAssignment_1; }
		
		//PRED_POSITIVE_TOKEN
		public RuleCall getPositivePRED_POSITIVE_TOKENParserRuleCall_1_0() { return cPositivePRED_POSITIVE_TOKENParserRuleCall_1_0; }
		
		//negative?=PRED_NEGATIVE_TOKEN
		public Assignment getNegativeAssignment_2() { return cNegativeAssignment_2; }
		
		//PRED_NEGATIVE_TOKEN
		public RuleCall getNegativePRED_NEGATIVE_TOKENParserRuleCall_2_0() { return cNegativePRED_NEGATIVE_TOKENParserRuleCall_2_0; }
	}
	public class NOT_TOKENElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "no.sintef.xtext.dsl.operator.Realop.NOT_TOKEN");
		private final Keyword cNotKeyword = (Keyword)rule.eContents().get(1);
		
		//NOT_TOKEN:
		//	'not';
		@Override public ParserRule getRule() { return rule; }
		
		//'not'
		public Keyword getNotKeyword() { return cNotKeyword; }
	}
	public class AND_TOKENElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "no.sintef.xtext.dsl.operator.Realop.AND_TOKEN");
		private final Keyword cAndKeyword = (Keyword)rule.eContents().get(1);
		
		//AND_TOKEN:
		//	'and';
		@Override public ParserRule getRule() { return rule; }
		
		//'and'
		public Keyword getAndKeyword() { return cAndKeyword; }
	}
	public class OR_TOKENElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "no.sintef.xtext.dsl.operator.Realop.OR_TOKEN");
		private final Keyword cOrKeyword = (Keyword)rule.eContents().get(1);
		
		//OR_TOKEN:
		//	'or';
		@Override public ParserRule getRule() { return rule; }
		
		//'or'
		public Keyword getOrKeyword() { return cOrKeyword; }
	}
	public class XOR_TOKENElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "no.sintef.xtext.dsl.operator.Realop.XOR_TOKEN");
		private final Keyword cXorKeyword = (Keyword)rule.eContents().get(1);
		
		//XOR_TOKEN:
		//	'xor';
		@Override public ParserRule getRule() { return rule; }
		
		//'xor'
		public Keyword getXorKeyword() { return cXorKeyword; }
	}
	public class PRED_REALISED_TOKENElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "no.sintef.xtext.dsl.operator.Realop.PRED_REALISED_TOKEN");
		private final Keyword cRealisedKeyword = (Keyword)rule.eContents().get(1);
		
		//PRED_REALISED_TOKEN:
		//	'realised';
		@Override public ParserRule getRule() { return rule; }
		
		//'realised'
		public Keyword getRealisedKeyword() { return cRealisedKeyword; }
	}
	public class PRED_POSITIVE_TOKENElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "no.sintef.xtext.dsl.operator.Realop.PRED_POSITIVE_TOKEN");
		private final Keyword cPositiveKeyword = (Keyword)rule.eContents().get(1);
		
		//PRED_POSITIVE_TOKEN:
		//	'positive';
		@Override public ParserRule getRule() { return rule; }
		
		//'positive'
		public Keyword getPositiveKeyword() { return cPositiveKeyword; }
	}
	public class PRED_NEGATIVE_TOKENElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "no.sintef.xtext.dsl.operator.Realop.PRED_NEGATIVE_TOKEN");
		private final Keyword cNegativeKeyword = (Keyword)rule.eContents().get(1);
		
		//PRED_NEGATIVE_TOKEN:
		//	'negative';
		@Override public ParserRule getRule() { return rule; }
		
		//'negative'
		public Keyword getNegativeKeyword() { return cNegativeKeyword; }
	}
	public class OP_TOKENElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "no.sintef.xtext.dsl.operator.Realop.OP_TOKEN");
		private final Keyword cOperatorKeyword = (Keyword)rule.eContents().get(1);
		
		//OP_TOKEN:
		//	'operator';
		@Override public ParserRule getRule() { return rule; }
		
		//'operator'
		public Keyword getOperatorKeyword() { return cOperatorKeyword; }
	}
	public class OPEN_OP_TOKENElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "no.sintef.xtext.dsl.operator.Realop.OPEN_OP_TOKEN");
		private final Keyword cLeftCurlyBracketKeyword = (Keyword)rule.eContents().get(1);
		
		//OPEN_OP_TOKEN:
		//	'{';
		@Override public ParserRule getRule() { return rule; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword() { return cLeftCurlyBracketKeyword; }
	}
	public class CLOSE_OP_TOKENElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "no.sintef.xtext.dsl.operator.Realop.CLOSE_OP_TOKEN");
		private final Keyword cRightCurlyBracketKeyword = (Keyword)rule.eContents().get(1);
		
		//CLOSE_OP_TOKEN:
		//	'}';
		@Override public ParserRule getRule() { return rule; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword() { return cRightCurlyBracketKeyword; }
	}
	public class PRE_TOKENElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "no.sintef.xtext.dsl.operator.Realop.PRE_TOKEN");
		private final Keyword cPreKeyword = (Keyword)rule.eContents().get(1);
		
		//PRE_TOKEN:
		//	'pre';
		@Override public ParserRule getRule() { return rule; }
		
		//'pre'
		public Keyword getPreKeyword() { return cPreKeyword; }
	}
	public class POST_TOKENElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "no.sintef.xtext.dsl.operator.Realop.POST_TOKEN");
		private final Keyword cPostKeyword = (Keyword)rule.eContents().get(1);
		
		//POST_TOKEN:
		//	'post';
		@Override public ParserRule getRule() { return rule; }
		
		//'post'
		public Keyword getPostKeyword() { return cPostKeyword; }
	}
	public class COND_ST_TOKENElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "no.sintef.xtext.dsl.operator.Realop.COND_ST_TOKEN");
		private final Keyword cColonKeyword = (Keyword)rule.eContents().get(1);
		
		//COND_ST_TOKEN:
		//	':';
		@Override public ParserRule getRule() { return rule; }
		
		//':'
		public Keyword getColonKeyword() { return cColonKeyword; }
	}
	public class COND_END_TOKENElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "no.sintef.xtext.dsl.operator.Realop.COND_END_TOKEN");
		private final Keyword cSemicolonKeyword = (Keyword)rule.eContents().get(1);
		
		//COND_END_TOKEN:
		//	';';
		@Override public ParserRule getRule() { return rule; }
		
		//';'
		public Keyword getSemicolonKeyword() { return cSemicolonKeyword; }
	}
	
	
	private final RealopElements pRealop;
	private final OperatorElements pOperator;
	private final ExpressionElements pExpression;
	private final TerminalExpressionElements pTerminalExpression;
	private final LogicElements pLogic;
	private final PredicateElements pPredicate;
	private final PredicatesElements pPredicates;
	private final NOT_TOKENElements pNOT_TOKEN;
	private final AND_TOKENElements pAND_TOKEN;
	private final OR_TOKENElements pOR_TOKEN;
	private final XOR_TOKENElements pXOR_TOKEN;
	private final PRED_REALISED_TOKENElements pPRED_REALISED_TOKEN;
	private final PRED_POSITIVE_TOKENElements pPRED_POSITIVE_TOKEN;
	private final PRED_NEGATIVE_TOKENElements pPRED_NEGATIVE_TOKEN;
	private final OP_TOKENElements pOP_TOKEN;
	private final OPEN_OP_TOKENElements pOPEN_OP_TOKEN;
	private final CLOSE_OP_TOKENElements pCLOSE_OP_TOKEN;
	private final PRE_TOKENElements pPRE_TOKEN;
	private final POST_TOKENElements pPOST_TOKEN;
	private final COND_ST_TOKENElements pCOND_ST_TOKEN;
	private final COND_END_TOKENElements pCOND_END_TOKEN;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public RealopGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pRealop = new RealopElements();
		this.pOperator = new OperatorElements();
		this.pExpression = new ExpressionElements();
		this.pTerminalExpression = new TerminalExpressionElements();
		this.pLogic = new LogicElements();
		this.pPredicate = new PredicateElements();
		this.pPredicates = new PredicatesElements();
		this.pNOT_TOKEN = new NOT_TOKENElements();
		this.pAND_TOKEN = new AND_TOKENElements();
		this.pOR_TOKEN = new OR_TOKENElements();
		this.pXOR_TOKEN = new XOR_TOKENElements();
		this.pPRED_REALISED_TOKEN = new PRED_REALISED_TOKENElements();
		this.pPRED_POSITIVE_TOKEN = new PRED_POSITIVE_TOKENElements();
		this.pPRED_NEGATIVE_TOKEN = new PRED_NEGATIVE_TOKENElements();
		this.pOP_TOKEN = new OP_TOKENElements();
		this.pOPEN_OP_TOKEN = new OPEN_OP_TOKENElements();
		this.pCLOSE_OP_TOKEN = new CLOSE_OP_TOKENElements();
		this.pPRE_TOKEN = new PRE_TOKENElements();
		this.pPOST_TOKEN = new POST_TOKENElements();
		this.pCOND_ST_TOKEN = new COND_ST_TOKENElements();
		this.pCOND_END_TOKEN = new COND_END_TOKENElements();
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("no.sintef.xtext.dsl.operator.Realop".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//Realop:
	//	operator+=Operator*;
	public RealopElements getRealopAccess() {
		return pRealop;
	}
	
	public ParserRule getRealopRule() {
		return getRealopAccess().getRule();
	}
	
	//Operator:
	//	OP_TOKEN name=ID OPEN_OP_TOKEN PRE_TOKEN COND_ST_TOKEN exp_pre=Expression COND_END_TOKEN POST_TOKEN COND_ST_TOKEN
	//	exp_post=Expression COND_END_TOKEN CLOSE_OP_TOKEN;
	public OperatorElements getOperatorAccess() {
		return pOperator;
	}
	
	public ParserRule getOperatorRule() {
		return getOperatorAccess().getRule();
	}
	
	//Expression:
	//	lhs=Predicate rhs=TerminalExpression?;
	public ExpressionElements getExpressionAccess() {
		return pExpression;
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}
	
	//TerminalExpression:
	//	op=Logic rhs=Expression;
	public TerminalExpressionElements getTerminalExpressionAccess() {
		return pTerminalExpression;
	}
	
	public ParserRule getTerminalExpressionRule() {
		return getTerminalExpressionAccess().getRule();
	}
	
	//Logic:
	//	and?=AND_TOKEN | or?=OR_TOKEN | xor?=XOR_TOKEN;
	public LogicElements getLogicAccess() {
		return pLogic;
	}
	
	public ParserRule getLogicRule() {
		return getLogicAccess().getRule();
	}
	
	//Predicate:
	//	negated?=NOT_TOKEN? predicate=Predicates '(' name=ID ')';
	public PredicateElements getPredicateAccess() {
		return pPredicate;
	}
	
	public ParserRule getPredicateRule() {
		return getPredicateAccess().getRule();
	}
	
	//Predicates:
	//	realised?=PRED_REALISED_TOKEN | positive?=PRED_POSITIVE_TOKEN | negative?=PRED_NEGATIVE_TOKEN;
	public PredicatesElements getPredicatesAccess() {
		return pPredicates;
	}
	
	public ParserRule getPredicatesRule() {
		return getPredicatesAccess().getRule();
	}
	
	//NOT_TOKEN:
	//	'not';
	public NOT_TOKENElements getNOT_TOKENAccess() {
		return pNOT_TOKEN;
	}
	
	public ParserRule getNOT_TOKENRule() {
		return getNOT_TOKENAccess().getRule();
	}
	
	//AND_TOKEN:
	//	'and';
	public AND_TOKENElements getAND_TOKENAccess() {
		return pAND_TOKEN;
	}
	
	public ParserRule getAND_TOKENRule() {
		return getAND_TOKENAccess().getRule();
	}
	
	//OR_TOKEN:
	//	'or';
	public OR_TOKENElements getOR_TOKENAccess() {
		return pOR_TOKEN;
	}
	
	public ParserRule getOR_TOKENRule() {
		return getOR_TOKENAccess().getRule();
	}
	
	//XOR_TOKEN:
	//	'xor';
	public XOR_TOKENElements getXOR_TOKENAccess() {
		return pXOR_TOKEN;
	}
	
	public ParserRule getXOR_TOKENRule() {
		return getXOR_TOKENAccess().getRule();
	}
	
	//PRED_REALISED_TOKEN:
	//	'realised';
	public PRED_REALISED_TOKENElements getPRED_REALISED_TOKENAccess() {
		return pPRED_REALISED_TOKEN;
	}
	
	public ParserRule getPRED_REALISED_TOKENRule() {
		return getPRED_REALISED_TOKENAccess().getRule();
	}
	
	//PRED_POSITIVE_TOKEN:
	//	'positive';
	public PRED_POSITIVE_TOKENElements getPRED_POSITIVE_TOKENAccess() {
		return pPRED_POSITIVE_TOKEN;
	}
	
	public ParserRule getPRED_POSITIVE_TOKENRule() {
		return getPRED_POSITIVE_TOKENAccess().getRule();
	}
	
	//PRED_NEGATIVE_TOKEN:
	//	'negative';
	public PRED_NEGATIVE_TOKENElements getPRED_NEGATIVE_TOKENAccess() {
		return pPRED_NEGATIVE_TOKEN;
	}
	
	public ParserRule getPRED_NEGATIVE_TOKENRule() {
		return getPRED_NEGATIVE_TOKENAccess().getRule();
	}
	
	//OP_TOKEN:
	//	'operator';
	public OP_TOKENElements getOP_TOKENAccess() {
		return pOP_TOKEN;
	}
	
	public ParserRule getOP_TOKENRule() {
		return getOP_TOKENAccess().getRule();
	}
	
	//OPEN_OP_TOKEN:
	//	'{';
	public OPEN_OP_TOKENElements getOPEN_OP_TOKENAccess() {
		return pOPEN_OP_TOKEN;
	}
	
	public ParserRule getOPEN_OP_TOKENRule() {
		return getOPEN_OP_TOKENAccess().getRule();
	}
	
	//CLOSE_OP_TOKEN:
	//	'}';
	public CLOSE_OP_TOKENElements getCLOSE_OP_TOKENAccess() {
		return pCLOSE_OP_TOKEN;
	}
	
	public ParserRule getCLOSE_OP_TOKENRule() {
		return getCLOSE_OP_TOKENAccess().getRule();
	}
	
	//PRE_TOKEN:
	//	'pre';
	public PRE_TOKENElements getPRE_TOKENAccess() {
		return pPRE_TOKEN;
	}
	
	public ParserRule getPRE_TOKENRule() {
		return getPRE_TOKENAccess().getRule();
	}
	
	//POST_TOKEN:
	//	'post';
	public POST_TOKENElements getPOST_TOKENAccess() {
		return pPOST_TOKEN;
	}
	
	public ParserRule getPOST_TOKENRule() {
		return getPOST_TOKENAccess().getRule();
	}
	
	//COND_ST_TOKEN:
	//	':';
	public COND_ST_TOKENElements getCOND_ST_TOKENAccess() {
		return pCOND_ST_TOKEN;
	}
	
	public ParserRule getCOND_ST_TOKENRule() {
		return getCOND_ST_TOKENAccess().getRule();
	}
	
	//COND_END_TOKEN:
	//	';';
	public COND_END_TOKENElements getCOND_END_TOKENAccess() {
		return pCOND_END_TOKEN;
	}
	
	public ParserRule getCOND_END_TOKENRule() {
		return getCOND_END_TOKENAccess().getRule();
	}
	
	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"' | "'" ('\\' . | !('\\' | "'"))* "'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	}
	
	//terminal ML_COMMENT:
	//	'/ *'->'* /';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}
