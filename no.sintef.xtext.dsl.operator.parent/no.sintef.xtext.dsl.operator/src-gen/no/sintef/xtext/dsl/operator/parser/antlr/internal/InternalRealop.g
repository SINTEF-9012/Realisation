/*
 * generated by Xtext 2.9.2
 */
grammar InternalRealop;

options {
	superClass=AbstractInternalAntlrParser;
}

@lexer::header {
package no.sintef.xtext.dsl.operator.parser.antlr.internal;

// Hack: Use our own Lexer superclass by means of import. 
// Currently there is no other way to specify the superclass for the lexer.
import org.eclipse.xtext.parser.antlr.Lexer;
}

@parser::header {
package no.sintef.xtext.dsl.operator.parser.antlr.internal;

import org.eclipse.xtext.*;
import org.eclipse.xtext.parser.*;
import org.eclipse.xtext.parser.impl.*;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.parser.antlr.AbstractInternalAntlrParser;
import org.eclipse.xtext.parser.antlr.XtextTokenStream;
import org.eclipse.xtext.parser.antlr.XtextTokenStream.HiddenTokens;
import org.eclipse.xtext.parser.antlr.AntlrDatatypeRuleToken;
import no.sintef.xtext.dsl.operator.services.RealopGrammarAccess;

}

@parser::members {

 	private RealopGrammarAccess grammarAccess;

    public InternalRealopParser(TokenStream input, RealopGrammarAccess grammarAccess) {
        this(input);
        this.grammarAccess = grammarAccess;
        registerRules(grammarAccess.getGrammar());
    }

    @Override
    protected String getFirstRuleName() {
    	return "Realop";
   	}

   	@Override
   	protected RealopGrammarAccess getGrammarAccess() {
   		return grammarAccess;
   	}

}

@rulecatch {
    catch (RecognitionException re) {
        recover(input,re);
        appendSkippedTokens();
    }
}

// Entry rule entryRuleRealop
entryRuleRealop returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getRealopRule()); }
	iv_ruleRealop=ruleRealop
	{ $current=$iv_ruleRealop.current; }
	EOF;

// Rule Realop
ruleRealop returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		(
			{
				newCompositeNode(grammarAccess.getRealopAccess().getOperatorOperatorParserRuleCall_0());
			}
			lv_operator_0_0=ruleOperator
			{
				if ($current==null) {
					$current = createModelElementForParent(grammarAccess.getRealopRule());
				}
				add(
					$current,
					"operator",
					lv_operator_0_0,
					"no.sintef.xtext.dsl.operator.Realop.Operator");
				afterParserOrEnumRuleCall();
			}
		)
	)*
;

// Entry rule entryRuleOperator
entryRuleOperator returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getOperatorRule()); }
	iv_ruleOperator=ruleOperator
	{ $current=$iv_ruleOperator.current; }
	EOF;

// Rule Operator
ruleOperator returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		{
			newCompositeNode(grammarAccess.getOperatorAccess().getOP_TOKENParserRuleCall_0());
		}
		ruleOP_TOKEN
		{
			afterParserOrEnumRuleCall();
		}
		(
			(
				lv_name_1_0=RULE_ID
				{
					newLeafNode(lv_name_1_0, grammarAccess.getOperatorAccess().getNameIDTerminalRuleCall_1_0());
				}
				{
					if ($current==null) {
						$current = createModelElement(grammarAccess.getOperatorRule());
					}
					setWithLastConsumed(
						$current,
						"name",
						lv_name_1_0,
						"org.eclipse.xtext.common.Terminals.ID");
				}
			)
		)
		{
			newCompositeNode(grammarAccess.getOperatorAccess().getOPEN_OP_TOKENParserRuleCall_2());
		}
		ruleOPEN_OP_TOKEN
		{
			afterParserOrEnumRuleCall();
		}
		{
			newCompositeNode(grammarAccess.getOperatorAccess().getPRE_TOKENParserRuleCall_3());
		}
		rulePRE_TOKEN
		{
			afterParserOrEnumRuleCall();
		}
		{
			newCompositeNode(grammarAccess.getOperatorAccess().getCOND_ST_TOKENParserRuleCall_4());
		}
		ruleCOND_ST_TOKEN
		{
			afterParserOrEnumRuleCall();
		}
		(
			(
				{
					newCompositeNode(grammarAccess.getOperatorAccess().getExp_preExpressionParserRuleCall_5_0());
				}
				lv_exp_pre_5_0=ruleExpression
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getOperatorRule());
					}
					set(
						$current,
						"exp_pre",
						lv_exp_pre_5_0,
						"no.sintef.xtext.dsl.operator.Realop.Expression");
					afterParserOrEnumRuleCall();
				}
			)
		)
		{
			newCompositeNode(grammarAccess.getOperatorAccess().getCOND_END_TOKENParserRuleCall_6());
		}
		ruleCOND_END_TOKEN
		{
			afterParserOrEnumRuleCall();
		}
		{
			newCompositeNode(grammarAccess.getOperatorAccess().getPOST_TOKENParserRuleCall_7());
		}
		rulePOST_TOKEN
		{
			afterParserOrEnumRuleCall();
		}
		{
			newCompositeNode(grammarAccess.getOperatorAccess().getCOND_ST_TOKENParserRuleCall_8());
		}
		ruleCOND_ST_TOKEN
		{
			afterParserOrEnumRuleCall();
		}
		(
			(
				{
					newCompositeNode(grammarAccess.getOperatorAccess().getExp_postExpressionParserRuleCall_9_0());
				}
				lv_exp_post_9_0=ruleExpression
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getOperatorRule());
					}
					set(
						$current,
						"exp_post",
						lv_exp_post_9_0,
						"no.sintef.xtext.dsl.operator.Realop.Expression");
					afterParserOrEnumRuleCall();
				}
			)
		)
		{
			newCompositeNode(grammarAccess.getOperatorAccess().getCOND_END_TOKENParserRuleCall_10());
		}
		ruleCOND_END_TOKEN
		{
			afterParserOrEnumRuleCall();
		}
		{
			newCompositeNode(grammarAccess.getOperatorAccess().getCLOSE_OP_TOKENParserRuleCall_11());
		}
		ruleCLOSE_OP_TOKEN
		{
			afterParserOrEnumRuleCall();
		}
	)
;

// Entry rule entryRuleExpression
entryRuleExpression returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getExpressionRule()); }
	iv_ruleExpression=ruleExpression
	{ $current=$iv_ruleExpression.current; }
	EOF;

// Rule Expression
ruleExpression returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		(
			(
				{
					newCompositeNode(grammarAccess.getExpressionAccess().getLhsPredicateParserRuleCall_0_0());
				}
				lv_lhs_0_0=rulePredicate
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getExpressionRule());
					}
					set(
						$current,
						"lhs",
						lv_lhs_0_0,
						"no.sintef.xtext.dsl.operator.Realop.Predicate");
					afterParserOrEnumRuleCall();
				}
			)
		)
		(
			(
				{
					newCompositeNode(grammarAccess.getExpressionAccess().getRhsTerminalExpressionParserRuleCall_1_0());
				}
				lv_rhs_1_0=ruleTerminalExpression
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getExpressionRule());
					}
					set(
						$current,
						"rhs",
						lv_rhs_1_0,
						"no.sintef.xtext.dsl.operator.Realop.TerminalExpression");
					afterParserOrEnumRuleCall();
				}
			)
		)?
	)
;

// Entry rule entryRuleTerminalExpression
entryRuleTerminalExpression returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getTerminalExpressionRule()); }
	iv_ruleTerminalExpression=ruleTerminalExpression
	{ $current=$iv_ruleTerminalExpression.current; }
	EOF;

// Rule TerminalExpression
ruleTerminalExpression returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		(
			(
				{
					newCompositeNode(grammarAccess.getTerminalExpressionAccess().getOpLogicParserRuleCall_0_0());
				}
				lv_op_0_0=ruleLogic
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getTerminalExpressionRule());
					}
					set(
						$current,
						"op",
						lv_op_0_0,
						"no.sintef.xtext.dsl.operator.Realop.Logic");
					afterParserOrEnumRuleCall();
				}
			)
		)
		(
			(
				{
					newCompositeNode(grammarAccess.getTerminalExpressionAccess().getRhsExpressionParserRuleCall_1_0());
				}
				lv_rhs_1_0=ruleExpression
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getTerminalExpressionRule());
					}
					set(
						$current,
						"rhs",
						lv_rhs_1_0,
						"no.sintef.xtext.dsl.operator.Realop.Expression");
					afterParserOrEnumRuleCall();
				}
			)
		)
	)
;

// Entry rule entryRuleLogic
entryRuleLogic returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getLogicRule()); }
	iv_ruleLogic=ruleLogic
	{ $current=$iv_ruleLogic.current; }
	EOF;

// Rule Logic
ruleLogic returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		(
			(
				{
					newCompositeNode(grammarAccess.getLogicAccess().getAndAND_TOKENParserRuleCall_0_0());
				}
				lv_and_0_0=ruleAND_TOKEN
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getLogicRule());
					}
					set(
						$current,
						"and",
						true,
						"no.sintef.xtext.dsl.operator.Realop.AND_TOKEN");
					afterParserOrEnumRuleCall();
				}
			)
		)
		    |
		(
			(
				{
					newCompositeNode(grammarAccess.getLogicAccess().getOrOR_TOKENParserRuleCall_1_0());
				}
				lv_or_1_0=ruleOR_TOKEN
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getLogicRule());
					}
					set(
						$current,
						"or",
						true,
						"no.sintef.xtext.dsl.operator.Realop.OR_TOKEN");
					afterParserOrEnumRuleCall();
				}
			)
		)
		    |
		(
			(
				{
					newCompositeNode(grammarAccess.getLogicAccess().getXorXOR_TOKENParserRuleCall_2_0());
				}
				lv_xor_2_0=ruleXOR_TOKEN
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getLogicRule());
					}
					set(
						$current,
						"xor",
						true,
						"no.sintef.xtext.dsl.operator.Realop.XOR_TOKEN");
					afterParserOrEnumRuleCall();
				}
			)
		)
	)
;

// Entry rule entryRulePredicate
entryRulePredicate returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getPredicateRule()); }
	iv_rulePredicate=rulePredicate
	{ $current=$iv_rulePredicate.current; }
	EOF;

// Rule Predicate
rulePredicate returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		(
			(
				{
					newCompositeNode(grammarAccess.getPredicateAccess().getNegatedNOT_TOKENParserRuleCall_0_0());
				}
				lv_negated_0_0=ruleNOT_TOKEN
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getPredicateRule());
					}
					set(
						$current,
						"negated",
						true,
						"no.sintef.xtext.dsl.operator.Realop.NOT_TOKEN");
					afterParserOrEnumRuleCall();
				}
			)
		)?
		(
			(
				{
					newCompositeNode(grammarAccess.getPredicateAccess().getPredicatePredicatesParserRuleCall_1_0());
				}
				lv_predicate_1_0=rulePredicates
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getPredicateRule());
					}
					set(
						$current,
						"predicate",
						lv_predicate_1_0,
						"no.sintef.xtext.dsl.operator.Realop.Predicates");
					afterParserOrEnumRuleCall();
				}
			)
		)
		otherlv_2='('
		{
			newLeafNode(otherlv_2, grammarAccess.getPredicateAccess().getLeftParenthesisKeyword_2());
		}
		(
			(
				lv_name_3_0=RULE_ID
				{
					newLeafNode(lv_name_3_0, grammarAccess.getPredicateAccess().getNameIDTerminalRuleCall_3_0());
				}
				{
					if ($current==null) {
						$current = createModelElement(grammarAccess.getPredicateRule());
					}
					setWithLastConsumed(
						$current,
						"name",
						lv_name_3_0,
						"org.eclipse.xtext.common.Terminals.ID");
				}
			)
		)
		otherlv_4=')'
		{
			newLeafNode(otherlv_4, grammarAccess.getPredicateAccess().getRightParenthesisKeyword_4());
		}
	)
;

// Entry rule entryRulePredicates
entryRulePredicates returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getPredicatesRule()); }
	iv_rulePredicates=rulePredicates
	{ $current=$iv_rulePredicates.current; }
	EOF;

// Rule Predicates
rulePredicates returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		(
			(
				{
					newCompositeNode(grammarAccess.getPredicatesAccess().getRealisedPRED_REALISED_TOKENParserRuleCall_0_0());
				}
				lv_realised_0_0=rulePRED_REALISED_TOKEN
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getPredicatesRule());
					}
					set(
						$current,
						"realised",
						true,
						"no.sintef.xtext.dsl.operator.Realop.PRED_REALISED_TOKEN");
					afterParserOrEnumRuleCall();
				}
			)
		)
		    |
		(
			(
				{
					newCompositeNode(grammarAccess.getPredicatesAccess().getPositivePRED_POSITIVE_TOKENParserRuleCall_1_0());
				}
				lv_positive_1_0=rulePRED_POSITIVE_TOKEN
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getPredicatesRule());
					}
					set(
						$current,
						"positive",
						true,
						"no.sintef.xtext.dsl.operator.Realop.PRED_POSITIVE_TOKEN");
					afterParserOrEnumRuleCall();
				}
			)
		)
		    |
		(
			(
				{
					newCompositeNode(grammarAccess.getPredicatesAccess().getNegativePRED_NEGATIVE_TOKENParserRuleCall_2_0());
				}
				lv_negative_2_0=rulePRED_NEGATIVE_TOKEN
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getPredicatesRule());
					}
					set(
						$current,
						"negative",
						true,
						"no.sintef.xtext.dsl.operator.Realop.PRED_NEGATIVE_TOKEN");
					afterParserOrEnumRuleCall();
				}
			)
		)
	)
;

// Entry rule entryRuleNOT_TOKEN
entryRuleNOT_TOKEN returns [String current=null]:
	{ newCompositeNode(grammarAccess.getNOT_TOKENRule()); }
	iv_ruleNOT_TOKEN=ruleNOT_TOKEN
	{ $current=$iv_ruleNOT_TOKEN.current.getText(); }
	EOF;

// Rule NOT_TOKEN
ruleNOT_TOKEN returns [AntlrDatatypeRuleToken current=new AntlrDatatypeRuleToken()]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	kw='not'
	{
		$current.merge(kw);
		newLeafNode(kw, grammarAccess.getNOT_TOKENAccess().getNotKeyword());
	}
;

// Entry rule entryRuleAND_TOKEN
entryRuleAND_TOKEN returns [String current=null]:
	{ newCompositeNode(grammarAccess.getAND_TOKENRule()); }
	iv_ruleAND_TOKEN=ruleAND_TOKEN
	{ $current=$iv_ruleAND_TOKEN.current.getText(); }
	EOF;

// Rule AND_TOKEN
ruleAND_TOKEN returns [AntlrDatatypeRuleToken current=new AntlrDatatypeRuleToken()]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	kw='and'
	{
		$current.merge(kw);
		newLeafNode(kw, grammarAccess.getAND_TOKENAccess().getAndKeyword());
	}
;

// Entry rule entryRuleOR_TOKEN
entryRuleOR_TOKEN returns [String current=null]:
	{ newCompositeNode(grammarAccess.getOR_TOKENRule()); }
	iv_ruleOR_TOKEN=ruleOR_TOKEN
	{ $current=$iv_ruleOR_TOKEN.current.getText(); }
	EOF;

// Rule OR_TOKEN
ruleOR_TOKEN returns [AntlrDatatypeRuleToken current=new AntlrDatatypeRuleToken()]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	kw='or'
	{
		$current.merge(kw);
		newLeafNode(kw, grammarAccess.getOR_TOKENAccess().getOrKeyword());
	}
;

// Entry rule entryRuleXOR_TOKEN
entryRuleXOR_TOKEN returns [String current=null]:
	{ newCompositeNode(grammarAccess.getXOR_TOKENRule()); }
	iv_ruleXOR_TOKEN=ruleXOR_TOKEN
	{ $current=$iv_ruleXOR_TOKEN.current.getText(); }
	EOF;

// Rule XOR_TOKEN
ruleXOR_TOKEN returns [AntlrDatatypeRuleToken current=new AntlrDatatypeRuleToken()]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	kw='xor'
	{
		$current.merge(kw);
		newLeafNode(kw, grammarAccess.getXOR_TOKENAccess().getXorKeyword());
	}
;

// Entry rule entryRulePRED_REALISED_TOKEN
entryRulePRED_REALISED_TOKEN returns [String current=null]:
	{ newCompositeNode(grammarAccess.getPRED_REALISED_TOKENRule()); }
	iv_rulePRED_REALISED_TOKEN=rulePRED_REALISED_TOKEN
	{ $current=$iv_rulePRED_REALISED_TOKEN.current.getText(); }
	EOF;

// Rule PRED_REALISED_TOKEN
rulePRED_REALISED_TOKEN returns [AntlrDatatypeRuleToken current=new AntlrDatatypeRuleToken()]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	kw='realised'
	{
		$current.merge(kw);
		newLeafNode(kw, grammarAccess.getPRED_REALISED_TOKENAccess().getRealisedKeyword());
	}
;

// Entry rule entryRulePRED_POSITIVE_TOKEN
entryRulePRED_POSITIVE_TOKEN returns [String current=null]:
	{ newCompositeNode(grammarAccess.getPRED_POSITIVE_TOKENRule()); }
	iv_rulePRED_POSITIVE_TOKEN=rulePRED_POSITIVE_TOKEN
	{ $current=$iv_rulePRED_POSITIVE_TOKEN.current.getText(); }
	EOF;

// Rule PRED_POSITIVE_TOKEN
rulePRED_POSITIVE_TOKEN returns [AntlrDatatypeRuleToken current=new AntlrDatatypeRuleToken()]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	kw='positive'
	{
		$current.merge(kw);
		newLeafNode(kw, grammarAccess.getPRED_POSITIVE_TOKENAccess().getPositiveKeyword());
	}
;

// Entry rule entryRulePRED_NEGATIVE_TOKEN
entryRulePRED_NEGATIVE_TOKEN returns [String current=null]:
	{ newCompositeNode(grammarAccess.getPRED_NEGATIVE_TOKENRule()); }
	iv_rulePRED_NEGATIVE_TOKEN=rulePRED_NEGATIVE_TOKEN
	{ $current=$iv_rulePRED_NEGATIVE_TOKEN.current.getText(); }
	EOF;

// Rule PRED_NEGATIVE_TOKEN
rulePRED_NEGATIVE_TOKEN returns [AntlrDatatypeRuleToken current=new AntlrDatatypeRuleToken()]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	kw='negative'
	{
		$current.merge(kw);
		newLeafNode(kw, grammarAccess.getPRED_NEGATIVE_TOKENAccess().getNegativeKeyword());
	}
;

// Entry rule entryRuleOP_TOKEN
entryRuleOP_TOKEN returns [String current=null]:
	{ newCompositeNode(grammarAccess.getOP_TOKENRule()); }
	iv_ruleOP_TOKEN=ruleOP_TOKEN
	{ $current=$iv_ruleOP_TOKEN.current.getText(); }
	EOF;

// Rule OP_TOKEN
ruleOP_TOKEN returns [AntlrDatatypeRuleToken current=new AntlrDatatypeRuleToken()]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	kw='operator'
	{
		$current.merge(kw);
		newLeafNode(kw, grammarAccess.getOP_TOKENAccess().getOperatorKeyword());
	}
;

// Entry rule entryRuleOPEN_OP_TOKEN
entryRuleOPEN_OP_TOKEN returns [String current=null]:
	{ newCompositeNode(grammarAccess.getOPEN_OP_TOKENRule()); }
	iv_ruleOPEN_OP_TOKEN=ruleOPEN_OP_TOKEN
	{ $current=$iv_ruleOPEN_OP_TOKEN.current.getText(); }
	EOF;

// Rule OPEN_OP_TOKEN
ruleOPEN_OP_TOKEN returns [AntlrDatatypeRuleToken current=new AntlrDatatypeRuleToken()]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	kw='{'
	{
		$current.merge(kw);
		newLeafNode(kw, grammarAccess.getOPEN_OP_TOKENAccess().getLeftCurlyBracketKeyword());
	}
;

// Entry rule entryRuleCLOSE_OP_TOKEN
entryRuleCLOSE_OP_TOKEN returns [String current=null]:
	{ newCompositeNode(grammarAccess.getCLOSE_OP_TOKENRule()); }
	iv_ruleCLOSE_OP_TOKEN=ruleCLOSE_OP_TOKEN
	{ $current=$iv_ruleCLOSE_OP_TOKEN.current.getText(); }
	EOF;

// Rule CLOSE_OP_TOKEN
ruleCLOSE_OP_TOKEN returns [AntlrDatatypeRuleToken current=new AntlrDatatypeRuleToken()]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	kw='}'
	{
		$current.merge(kw);
		newLeafNode(kw, grammarAccess.getCLOSE_OP_TOKENAccess().getRightCurlyBracketKeyword());
	}
;

// Entry rule entryRulePRE_TOKEN
entryRulePRE_TOKEN returns [String current=null]:
	{ newCompositeNode(grammarAccess.getPRE_TOKENRule()); }
	iv_rulePRE_TOKEN=rulePRE_TOKEN
	{ $current=$iv_rulePRE_TOKEN.current.getText(); }
	EOF;

// Rule PRE_TOKEN
rulePRE_TOKEN returns [AntlrDatatypeRuleToken current=new AntlrDatatypeRuleToken()]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	kw='pre'
	{
		$current.merge(kw);
		newLeafNode(kw, grammarAccess.getPRE_TOKENAccess().getPreKeyword());
	}
;

// Entry rule entryRulePOST_TOKEN
entryRulePOST_TOKEN returns [String current=null]:
	{ newCompositeNode(grammarAccess.getPOST_TOKENRule()); }
	iv_rulePOST_TOKEN=rulePOST_TOKEN
	{ $current=$iv_rulePOST_TOKEN.current.getText(); }
	EOF;

// Rule POST_TOKEN
rulePOST_TOKEN returns [AntlrDatatypeRuleToken current=new AntlrDatatypeRuleToken()]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	kw='post'
	{
		$current.merge(kw);
		newLeafNode(kw, grammarAccess.getPOST_TOKENAccess().getPostKeyword());
	}
;

// Entry rule entryRuleCOND_ST_TOKEN
entryRuleCOND_ST_TOKEN returns [String current=null]:
	{ newCompositeNode(grammarAccess.getCOND_ST_TOKENRule()); }
	iv_ruleCOND_ST_TOKEN=ruleCOND_ST_TOKEN
	{ $current=$iv_ruleCOND_ST_TOKEN.current.getText(); }
	EOF;

// Rule COND_ST_TOKEN
ruleCOND_ST_TOKEN returns [AntlrDatatypeRuleToken current=new AntlrDatatypeRuleToken()]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	kw=':'
	{
		$current.merge(kw);
		newLeafNode(kw, grammarAccess.getCOND_ST_TOKENAccess().getColonKeyword());
	}
;

// Entry rule entryRuleCOND_END_TOKEN
entryRuleCOND_END_TOKEN returns [String current=null]:
	{ newCompositeNode(grammarAccess.getCOND_END_TOKENRule()); }
	iv_ruleCOND_END_TOKEN=ruleCOND_END_TOKEN
	{ $current=$iv_ruleCOND_END_TOKEN.current.getText(); }
	EOF;

// Rule COND_END_TOKEN
ruleCOND_END_TOKEN returns [AntlrDatatypeRuleToken current=new AntlrDatatypeRuleToken()]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	kw=';'
	{
		$current.merge(kw);
		newLeafNode(kw, grammarAccess.getCOND_END_TOKENAccess().getSemicolonKeyword());
	}
;

RULE_ID : '^'? ('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;

RULE_INT : ('0'..'9')+;

RULE_STRING : ('"' ('\\' .|~(('\\'|'"')))* '"'|'\'' ('\\' .|~(('\\'|'\'')))* '\'');

RULE_ML_COMMENT : '/*' ( options {greedy=false;} : . )*'*/';

RULE_SL_COMMENT : '//' ~(('\n'|'\r'))* ('\r'? '\n')?;

RULE_WS : (' '|'\t'|'\r'|'\n')+;

RULE_ANY_OTHER : .;
